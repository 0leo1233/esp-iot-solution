/*
 * SPDX-FileCopyrightText: 2023 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Unlicense OR CC0-1.0
 */

#include <stdio.h>
#include <math.h>
#include "sdkconfig.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2s_std.h"
#include "driver/gpio.h"
#include "tusb.h"
#include "usb_device_uac.h"

static const char *TAG = "usb_uac_main";

#if CONFIG_UAC_MIC_CHANNEL_NUM
#define MIC_LEN                     (CONFIG_UAC_MIC_CHANNEL_NUM * CONFIG_UAC_SAMPLE_RATE / 1000 * CONFIG_UAC_MIC_INTERVAL * 2)
#define EXAMPLE_STD_BCLK_IO1        GPIO_NUM_2             // I2S bit clock io number
#define EXAMPLE_STD_WS_IO1          GPIO_NUM_3             // I2S word select io number
#define EXAMPLE_STD_DOUT_IO1        GPIO_NUM_4             // I2S data out io number

static i2s_chan_handle_t            tx_chan;               // I2S tx channel handler
static i2s_chan_handle_t            rx_chan;               // I2S rx channel handler
static TaskHandle_t                 i2s_write_task_handle; // I2S write task handle
#endif

static esp_err_t uac_device_output_cb(uint8_t *buf, uint32_t len, void *arg)
{
    ESP_LOGI(TAG, "receive data len: %"PRIu32"", len);
    return ESP_OK;
}

static esp_err_t uac_device_input_cb(uint8_t *buf, uint32_t len, uint32_t *bytes_read, void *arg)
{
#if CONFIG_UAC_MIC_CHANNEL_NUM
    if (i2s_channel_read(rx_chan, buf, len, (size_t *)bytes_read, 10) != ESP_OK) {
        ESP_LOGE(TAG, "i2s read failed");
    }
    xTaskNotifyGive(i2s_write_task_handle);
#endif
    return ESP_OK;
}

static void uac_device_set_mute_cb(uint32_t mute, void *arg)
{
    ESP_LOGI(TAG, "uac_device_set_mute_cb: %"PRIu32"", mute);
}

static void uac_device_set_volume_cb(uint32_t volume, void *arg)
{
    ESP_LOGI(TAG, "uac_device_set_volume_cb: %"PRIu32"", volume);
}

#if CONFIG_UAC_MIC_CHANNEL_NUM
static void i2s_example_write_task(void *args)
{
    int16_t *w_buf = (int16_t *)calloc(1, MIC_LEN);
    assert(w_buf); // Check if w_buf allocation success

    /* Assign w_buf */
#if CONFIG_UAC_MIC_CHANNEL_NUM == 1
    for (int i = 0; i < MIC_LEN / 2; i++) {
        w_buf[i] = (int16_t)(15000 * sin(2 * M_PI * 1000 * i / CONFIG_UAC_SAMPLE_RATE));
    }
#elif CONFIG_UAC_MIC_CHANNEL_NUM == 2
    for (int i = 0; i < MIC_LEN / 4; i++) {
        w_buf[2 * i] = (int16_t)(15000 * sin(2 * M_PI * 1000 * i / CONFIG_UAC_SAMPLE_RATE));
        w_buf[2 * i + 1] = (int16_t)(15000 * sin(2 * M_PI * 1000 * i / CONFIG_UAC_SAMPLE_RATE));
    }
#else
#error "MIC channel not support"
#endif

    size_t w_bytes = MIC_LEN;

    /* (Optional) Preload the data before enabling the TX channel, so that the valid data can be transmitted immediately */
    /* Here we load the target buffer repeatedly, until all the DMA buffers are preloaded */
    ESP_ERROR_CHECK(i2s_channel_preload_data(tx_chan, w_buf, MIC_LEN, &w_bytes));

    /* Enable the TX channel */
    ESP_ERROR_CHECK(i2s_channel_enable(rx_chan));
    ESP_ERROR_CHECK(i2s_channel_enable(tx_chan));
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        /* Write i2s data */
        if (i2s_channel_write(tx_chan, w_buf, MIC_LEN, &w_bytes, 1000) != ESP_OK) {
            printf("Write Task: i2s write failed\n");
        }
    }
    free(w_buf);
    vTaskDelete(NULL);
}

static void i2s_example_init(void)
{
    /* Setp 1: Determine the I2S channel configuration and allocate both channels
     * The default configuration can be generated by the helper macro,
     * it only requires the I2S controller id and I2S role */
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_chan, &rx_chan));

    /* Step 2: Setting the configurations of standard mode, and initialize rx & tx channels
     * The slot configuration and clock configuration can be generated by the macros
     * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
     * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_std_config_t std_cfg = {
        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(CONFIG_UAC_SAMPLE_RATE),
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,    // some codecs may require mclk signal, this example doesn't need it
            .bclk = EXAMPLE_STD_BCLK_IO1,
            .ws   = EXAMPLE_STD_WS_IO1,
            .dout = EXAMPLE_STD_DOUT_IO1,
            .din  = EXAMPLE_STD_DOUT_IO1, // In duplex mode, bind output and input to a same gpio can loopback internally
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv   = false,
            },
        },
    };
    /* Initialize the channels */
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));
}
#endif

void app_main(void)
{
#if CONFIG_UAC_MIC_CHANNEL_NUM
    i2s_example_init();
    xTaskCreate(i2s_example_write_task, "i2s_example_write_task", 4096, NULL, 5, &i2s_write_task_handle);
#endif
    uac_device_config_t config = {
        .output_cb = uac_device_output_cb,
        .input_cb = uac_device_input_cb,
        .set_mute_cb = uac_device_set_mute_cb,
        .set_volume_cb = uac_device_set_volume_cb,
        .cb_ctx = NULL,
    };
    uac_device_init(&config);
    while (1) {
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
}
